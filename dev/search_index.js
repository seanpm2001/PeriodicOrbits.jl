var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Dednam, W. and Botha, A. E. (2014). Optimized shooting method for finding periodic orbits of nonlinear dynamical systems.\n\n\n\n","category":"page"},{"location":"api/#The-Public-API","page":"The Public API","title":"The Public API","text":"","category":"section"},{"location":"api/","page":"The Public API","title":"The Public API","text":"PeriodicOrbit\nInitialGuess\nperiodic_orbit\nperiodic_orbits","category":"page"},{"location":"api/#PeriodicOrbits.PeriodicOrbit","page":"The Public API","title":"PeriodicOrbits.PeriodicOrbit","text":"A structure that contains information about a periodic orbit.\n\npoints::StateSpaceSet - points of the periodic orbit. This container  always holds the complete orbit.\nT::Real - the period of the orbit\nstable::Union{Bool, Nothing} - local stability of the periodic orbit. Unknown stability  is set to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#PeriodicOrbits.InitialGuess","page":"The Public API","title":"PeriodicOrbits.InitialGuess","text":"A structure that contains an initial guess for a periodic orbit detection algorithms.\n\nu0::AbstractArray{<:Real} - guess of a point in the periodic orbit\nT::Union{Real, Nothing} - guess of period of the orbit. Some algorithms do not require  the period guess to be given, in which case T is set to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#PeriodicOrbits.periodic_orbit","page":"The Public API","title":"PeriodicOrbits.periodic_orbit","text":"periodic_orbit(ds::DynamicalSystem, alg::PeriodicOrbitFinder, ig::InitialGuess = InitialGuess(ds)) → PeriodicOrbit\n\nTry to find single periodic orbit of the dynamical system ds using the algorithm alg given some initial guess ig. For more details on the periodic orbit detection algorithms, see the documentation of the specific algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/#PeriodicOrbits.periodic_orbits","page":"The Public API","title":"PeriodicOrbits.periodic_orbits","text":"periodic_orbit(ds::DynamicalSystem, alg::PeriodicOrbitFinder, igs::Vector{InitialGuess} = InitialGuess(ds)) → Vector{PeriodicOrbit}\n\nTry to find multiple periodic orbits of the dynamical system ds using the algorithm alg given some initial guesses igs. For more details on the periodic orbit detection algorithms, see the documentation of the specific algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/#Algorithms-for-Discrete-Time-Systems","page":"The Public API","title":"Algorithms for Discrete-Time Systems","text":"","category":"section"},{"location":"api/#Algorithms-for-Continuous-Time-Systems","page":"The Public API","title":"Algorithms for Continuous-Time Systems","text":"","category":"section"},{"location":"api/","page":"The Public API","title":"The Public API","text":"OptimizedShooting","category":"page"},{"location":"developer/#Developer's-Docs","page":"Developer's Docs","title":"Developer's Docs","text":"","category":"section"},{"location":"developer/","page":"Developer's Docs","title":"Developer's Docs","text":"minimal_period\nisstable\nuniquepos\npoequal\nPeriodicOrbits.isdiscretetime\npodistance\nPeriodicOrbitFinder","category":"page"},{"location":"developer/#PeriodicOrbits.minimal_period","page":"Developer's Docs","title":"PeriodicOrbits.minimal_period","text":"minimal_period(ds::DynamicalSystem, po::PeriodicOrbit; kw...) → minT_po\n\nCompute the minimal period of the periodic orbit po of the dynamical system ds. Return the periodic orbit minT_po with the minimal period. In the literature, minimal  period is also called prime, principal or fundamental period.\n\nKeyword arguments\n\natol = 1e-4 : After stepping the point u0 for a time T, it must return to atol neighborhood of itself to be considered periodic.\nmaxiter = 40 : Maximum number of Poincare map iterations. Continuous-time systems only.  If the number of Poincare map iterations exceeds maxiter, but the point u0 has not  returned to atol neighborhood of itself, the original period po.T is returned.\n\nDescription\n\nFor discrete systems, a valid period would be any natural multiple of the minimal period.  Hence, all natural divisors of the period po.T are checked as a potential period.  A point u0 of the periodic orbit po is iterated n times and if the distance between  the initial point u0 and the final point is less than atol, the period of the orbit  is n.\n\nFor continuous systems, a point u0 of the periodic orbit is integrated for a very short  time. The resulting point u1 is used to create a normal vector a=(u1-u0) to a hyperplane  perpendicular to the trajectory at u0. A Poincare map is created using  this hyperplane. Using the Poincare map, the hyperplane crossings are checked. Time of the  first crossing that is within atol distance of the initial point u0 is the minimal  period. At most maxiter crossings are checked.\n\n\n\n\n\n","category":"function"},{"location":"developer/#PeriodicOrbits.isstable","page":"Developer's Docs","title":"PeriodicOrbits.isstable","text":"isstable(ds::CoreDynamicalSystem, po [, jac]) → new_po\n\nDetermine the local stability of the periodic orbit po using the jacobian rule jac.  Returns a new periodic orbit for which po.stable is set to true   if the periodic orbit  is stable or false if it is unstable.\n\nFor discrete-time systems, the stability is determined using eigenvalues of the jacobian  of po.T-th iterate of the dynamical system ds at the point po.points[1]. If the  maximum absolute value of the eigenvalues is less than 1, the periodic orbit is marked  as stable.\n\nFor continuous-time systems, the stability is determined by the Floquet multipliers of the  monodromy matrix. If the maximum absolute value of the Floquet multipliers is less than  1 (while neglecting the multiplier which is always 1), the periodic orbit is marked   as stable.\n\nThe default value of jacobian rule jac is obtained via automatic differentiation.\n\n\n\n\n\n","category":"function"},{"location":"developer/#PeriodicOrbits.uniquepos","page":"Developer's Docs","title":"PeriodicOrbits.uniquepos","text":"uniquepos(pos::Vector{PeriodicOrbit}, atol=1e-6) → Vector{PeriodicOrbit}\n\nReturn a vector of unique periodic orbits from the vector pos of periodic orbits. By unique we mean that the distance between any two periodic orbits in the vector is  greater than atol. To see details about the distance function, see podistance.\n\n\n\n\n\n","category":"function"},{"location":"developer/#PeriodicOrbits.poequal","page":"Developer's Docs","title":"PeriodicOrbits.poequal","text":"poequal(po1::PeriodicOrbit, po2::PeriodicOrbit; kwargs...) → true/false\n\nReturn true if the periodic orbits po1 and po2 are equal within the given thresholds.\n\nKeyword arguments\n\nTthres=1e-3 : difference in periods of the periodic orbits must be less than this threshold\ndthres=1e-3 : distance between periodic orbits must be less than this threshold\ndistance : distance function used to compute the distance between the periodic orbits\n\nDistance between the orbits is computed using the given distance function distance. The default distance function is StrictlyMinimumDistance(true, Euclidean()) which finds  the minimal Euclidean distance between any pair of points where one point belongs to po1  and the other to po2. For other options of the distance function, see  StateSpaceSets.set_distance. Custom distance function can be provided as well.\n\n\n\n\n\n","category":"function"},{"location":"developer/#DynamicalSystemsBase.isdiscretetime","page":"Developer's Docs","title":"DynamicalSystemsBase.isdiscretetime","text":"isdiscretetime(po::PeriodicOrbit) → true/false\n\nReturn true if the periodic orbit belongs to a discrete-time dynamical system, false if  it belongs to a continuous-time dynamical system.\n\n\n\n\n\nisdiscretetime(ds::DynamicalSystem) → true/false\n\nReturn true if ds operates in discrete time, or false if it is in continuous time. This is information deduced from the type of ds.\n\n\n\n\n\n","category":"function"},{"location":"developer/#PeriodicOrbits.podistance","page":"Developer's Docs","title":"PeriodicOrbits.podistance","text":"podistance(po1::PeriodicOrbit, po2::PeriodicOrbit, [, distance]) → Real\n\nCompute the distance between two periodic orbits po1 and po2.  Periodic orbits po1 and po2 and the dynamical system ds all have to  be either discrete-time or continuous-time. Distance between the periodic orbits is computed using the given distance function distance. The default distance function is StrictlyMinimumDistance(true, Euclidean()) which finds the minimal  Euclidean distance between any pair of points where one point belongs to po1 and the other to po2.  For other options of the distance function, see StateSpaceSets.set_distance. Custom distance function can be provided as well.\n\n\n\n\n\n","category":"function"},{"location":"developer/#PeriodicOrbits.PeriodicOrbitFinder","page":"Developer's Docs","title":"PeriodicOrbits.PeriodicOrbitFinder","text":"PeriodicOrbitFinder\n\nSupertype for all the periodic orbit  detection algorithms. Each of the concrete subtypes of PeriodicOrbitFinder should  represent one given algorithm for detecting periodic orbits. This subtype will include  all the necessary parameters for the algorithm to work and optionally their default values. \n\n\n\n\n\n","category":"type"},{"location":"#PeriodicOrbits.jl","page":"PeriodicOrbits.jl","title":"PeriodicOrbits.jl","text":"","category":"section"},{"location":"","page":"PeriodicOrbits.jl","title":"PeriodicOrbits.jl","text":"PeriodicOrbits","category":"page"},{"location":"#PeriodicOrbits","page":"PeriodicOrbits.jl","title":"PeriodicOrbits","text":"PeriodicOrbits.jl\n\n(Image: docsdev) (Image: docsstable) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nInterface and algorithms for finding periodic orbits (stable or unstable) in dynamical systems based on the DynamicalSystems.jl ecosystem.\n\nTo install it, run import Pkg; Pkg.add(\"PeriodicOrbits\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's attempt to detect a periodic orbit of the Lorenz system. First we define the Lorenz  system itself.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PeriodicOrbits\n\nfunction lorenz(u0=[0.0, 10.0, 0.0]; σ = 10.0, ρ = 28.0, β = 8/3)\n    return CoupledODEs(lorenz_rule, u0, [σ, ρ, β])\nend\n@inbounds function lorenz_rule(u, p, t)\n    du1 = p[1]*(u[2]-u[1])\n    du2 = u[1]*(p[2]-u[3]) - u[2]\n    du3 = u[1]*u[2] - p[3]*u[3]\n    return SVector{3}(du1, du2, du3)\nend\n\nds = lorenz()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we give initial guess of the location of the periodic orbit and its period.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"u0_guess = SVector(3.5, 3.0, 0.0)\nT_guess = 5.2\nig = InitialGuess(u0_guess, T_guess) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we pick an appropriate algorithm that will detect the PO. In this case we can use  any algorithm intended for continuous-time dynamical systems. We choose Optimized Shooting  algorithm, for more information see OptimizedShooting.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"alg = OptimizedShooting(Δt=0.01, n=3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we combine all the pieces to find the periodic orbit.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"po = periodic_orbit(ds, alg, ig)\npo","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The closed curve of the periodic orbit can be visualized using plotting library such as  Makie.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\nu0 = po.points[1]\nT = po.T\ntraj, t = trajectory(ds, T, u0; Dt = 0.01)\nfig = Figure()\nax = Axis3(fig[1,1], azimuth = 0.6pi, elevation= 0.1pi)\nlines!(ax, traj[:, 1], traj[:, 2], traj[:, 3], color = :blue, linewidth=1.7)\nscatter!(ax, u0)\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To ensure that the detected period is minimal, eg. it is not a multiple of the minimal  period, we can use minimal_period.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"minT_po = minimal_period(ds, po)\nminT_po","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Whether two periodic orbits are equivalent up to some tolerance. Function poequal  can be used.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"equal = poequal(po, minT_po; dthres=1e-3, Tthres=1e-3)\n\"Detected periodic orbit had minimal period: $(equal)\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To determine whether found periodic orbit is stable or unstable, we can apply  isstable function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"po = isstable(ds, po)\n\"Detected periodic orbit is $(po.stable ? \"stable\" : \"unstable\").\"","category":"page"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#Optimized-Shooting-Method","page":"Algorithms","title":"Optimized Shooting Method","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"OptimizedShooting","category":"page"},{"location":"algorithms/#PeriodicOrbits.OptimizedShooting","page":"Algorithms","title":"PeriodicOrbits.OptimizedShooting","text":"OptimizedShooting(; kwargs...)\n\nA shooting method (Dednam and Botha, 2014) that uses Levenberg-Marquardt optimization  to find periodic orbits of continuous-time dynamical systems.\n\nKeyword arguments\n\nΔt::Float64 = 1e-6: step between the points in the residual R. See below for details.\nn::Int64 = 2: n*dimension(ds) is the number of points in the residual R. See below  for details.\nnonlinear_solve_kwargs = (reltol=1e-6, abstol=1e-6, maxiters=1000): keyword arguments  to pass to the solve function from  NonlinearSolve.jl. For details on the  keywords see the respective package documentation.\n\nDescription\n\nLet us consider the following continuous-time dynamical system\n\nfracdxdt = f(x p t)\n\nDednam and Botha (Dednam and Botha, 2014) suggest to minimize the residual R defined as\n\nR = (x(T)-x(0) x(T+Delta t)-x(Delta t) dots \nx(T+(n-1)Delta t)-x((n-1)Delta t))\n\nwhere T is unknown period of a periodic orbit and x(t) is a solution at time t  given some unknown initial point. Initial guess of the period T and the initial point  is optimized by the Levenberg-Marquardt algorithm.\n\nIn our implementation, the keyword argument n corresponds to n in the residual R.  The keyword argument Δt corresponds to Delta t in the residual R.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Example","page":"Algorithms","title":"Example","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"using PeriodicOrbits\nusing CairoMakie\nusing OrdinaryDiffEq\n\n@inbounds function roessler_rule(u, p, t)\n    du1 = -u[2]-u[3]\n    du2 = u[1] + p[1]*u[2]\n    du3 = p[2] + u[3]*(u[1] - p[3])\n    return SVector{3}(du1, du2, du3)\nend\n\nfunction plot_result(res, ds; azimuth = 1.3 * pi, elevation = 0.3 * pi)\n    traj, t = trajectory(ds, res.T, res.points[1]; Dt = 0.01)\n    fig = Figure()\n    ax = Axis3(fig[1,1], azimuth = azimuth, elevation=elevation)\n    lines!(ax, traj[:, 1], traj[:, 2], traj[:, 3], color = :blue, linewidth=1.7)\n    scatter!(ax, res.points[1])\n    return fig\nend\n\nig = InitialGuess(SVector(2.0, 5.0, 10.0), 10.2)\nalg = OptimizedShooting(Δt=0.01, n=3)\nds = CoupledODEs(roessler_rule, [1.0, -2.0, 0.1], [0.15, 0.2, 3.5])\nres = periodic_orbit(ds, alg, ig)\nplot_result(res, ds; azimuth = 1.3pi, elevation=0.1pi)","category":"page"}]
}
